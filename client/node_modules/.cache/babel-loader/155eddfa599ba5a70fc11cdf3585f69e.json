{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"D:/Kapil D/Personal/DecentralizedDeliveries/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Kapil D/Personal/DecentralizedDeliveries/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { arrayify, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nvar logger = new Logger(version);\nexport function checkResultErrors(result) {\n  // Find the first error (if any)\n  var errors = [];\n\n  var checkErrors = function checkErrors(path, object) {\n    if (!Array.isArray(object)) {\n      return;\n    }\n\n    for (var key in object) {\n      var childPath = path.slice();\n      childPath.push(key);\n\n      try {\n        checkErrors(childPath, object[key]);\n      } catch (error) {\n        errors.push({\n          path: childPath,\n          error: error\n        });\n      }\n    }\n  };\n\n  checkErrors([], result);\n  return errors;\n}\nexport var Coder = /*#__PURE__*/function () {\n  function Coder(name, type, localName, dynamic) {\n    _classCallCheck(this, Coder);\n\n    // @TODO: defineReadOnly these\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n\n  _createClass(Coder, [{\n    key: \"_throwError\",\n    value: function _throwError(message, value) {\n      logger.throwArgumentError(message, this.localName, value);\n    }\n  }]);\n\n  return Coder;\n}();\nexport var Writer = /*#__PURE__*/function () {\n  function Writer(wordSize) {\n    _classCallCheck(this, Writer);\n\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    this._data = [];\n    this._dataLength = 0;\n    this._padding = new Uint8Array(wordSize);\n  }\n\n  _createClass(Writer, [{\n    key: \"data\",\n    get: function get() {\n      return hexConcat(this._data);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._dataLength;\n    }\n  }, {\n    key: \"_writeData\",\n    value: function _writeData(data) {\n      this._data.push(data);\n\n      this._dataLength += data.length;\n      return data.length;\n    }\n  }, {\n    key: \"appendWriter\",\n    value: function appendWriter(writer) {\n      return this._writeData(concat(writer._data));\n    } // Arrayish items; padded on the right to wordSize\n\n  }, {\n    key: \"writeBytes\",\n    value: function writeBytes(value) {\n      var bytes = arrayify(value);\n      var paddingOffset = bytes.length % this.wordSize;\n\n      if (paddingOffset) {\n        bytes = concat([bytes, this._padding.slice(paddingOffset)]);\n      }\n\n      return this._writeData(bytes);\n    }\n  }, {\n    key: \"_getValue\",\n    value: function _getValue(value) {\n      var bytes = arrayify(BigNumber.from(value));\n\n      if (bytes.length > this.wordSize) {\n        logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n          length: this.wordSize,\n          offset: bytes.length\n        });\n      }\n\n      if (bytes.length % this.wordSize) {\n        bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n      }\n\n      return bytes;\n    } // BigNumberish items; padded on the left to wordSize\n\n  }, {\n    key: \"writeValue\",\n    value: function writeValue(value) {\n      return this._writeData(this._getValue(value));\n    }\n  }, {\n    key: \"writeUpdatableValue\",\n    value: function writeUpdatableValue() {\n      var _this = this;\n\n      var offset = this._data.length;\n\n      this._data.push(this._padding);\n\n      this._dataLength += this.wordSize;\n      return function (value) {\n        _this._data[offset] = _this._getValue(value);\n      };\n    }\n  }]);\n\n  return Writer;\n}();\nexport var Reader = /*#__PURE__*/function () {\n  function Reader(data, wordSize, coerceFunc, allowLoose) {\n    _classCallCheck(this, Reader);\n\n    defineReadOnly(this, \"_data\", arrayify(data));\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n    defineReadOnly(this, \"allowLoose\", allowLoose);\n    this._offset = 0;\n  }\n\n  _createClass(Reader, [{\n    key: \"data\",\n    get: function get() {\n      return hexlify(this._data);\n    }\n  }, {\n    key: \"consumed\",\n    get: function get() {\n      return this._offset;\n    } // The default Coerce function\n\n  }, {\n    key: \"coerce\",\n    value: function coerce(name, value) {\n      if (this._coerceFunc) {\n        return this._coerceFunc(name, value);\n      }\n\n      return Reader.coerce(name, value);\n    }\n  }, {\n    key: \"_peekBytes\",\n    value: function _peekBytes(offset, length, loose) {\n      var alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n\n      if (this._offset + alignedLength > this._data.length) {\n        if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n          alignedLength = length;\n        } else {\n          logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n            length: this._data.length,\n            offset: this._offset + alignedLength\n          });\n        }\n      }\n\n      return this._data.slice(this._offset, this._offset + alignedLength);\n    }\n  }, {\n    key: \"subReader\",\n    value: function subReader(offset) {\n      return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n  }, {\n    key: \"readBytes\",\n    value: function readBytes(length, loose) {\n      var bytes = this._peekBytes(0, length, !!loose);\n\n      this._offset += bytes.length; // @TODO: Make sure the length..end bytes are all 0?\n\n      return bytes.slice(0, length);\n    }\n  }, {\n    key: \"readValue\",\n    value: function readValue() {\n      return BigNumber.from(this.readBytes(this.wordSize));\n    }\n  }], [{\n    key: \"coerce\",\n    value: function coerce(name, value) {\n      var match = name.match(\"^u?int([0-9]+)$\");\n\n      if (match && parseInt(match[1]) <= 48) {\n        value = value.toNumber();\n      }\n\n      return value;\n    }\n  }]);\n\n  return Reader;\n}();","map":{"version":3,"sources":["../../src.ts/coders/abstract-coder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nimport { arrayify, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\nexport function checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function (path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            }\n            catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nexport class Coder {\n    constructor(name, type, localName, dynamic) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    _throwError(message, value) {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n}\nexport class Writer {\n    constructor(wordSize) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n    get data() {\n        return hexConcat(this._data);\n    }\n    get length() { return this._dataLength; }\n    _writeData(data) {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this._writeData(concat(writer._data));\n    }\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value) {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([bytes, this._padding.slice(paddingOffset)]);\n        }\n        return this._writeData(bytes);\n    }\n    _getValue(value) {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n        }\n        return bytes;\n    }\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value) {\n        return this._writeData(this._getValue(value));\n    }\n    writeUpdatableValue() {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\nexport class Reader {\n    constructor(data, wordSize, coerceFunc, allowLoose) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n        this._offset = 0;\n    }\n    get data() { return hexlify(this._data); }\n    get consumed() { return this._offset; }\n    // The default Coerce function\n    static coerce(name, value) {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) {\n            value = value.toNumber();\n        }\n        return value;\n    }\n    coerce(name, value) {\n        if (this._coerceFunc) {\n            return this._coerceFunc(name, value);\n        }\n        return Reader.coerce(name, value);\n    }\n    _peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            }\n            else {\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength);\n    }\n    subReader(offset) {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n    readBytes(length, loose) {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    readValue() {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n//# sourceMappingURL=abstract-coder.js.map"]},"metadata":{},"sourceType":"module"}